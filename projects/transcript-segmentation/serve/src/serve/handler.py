"""Transcript Segmentation."""

# Standard Library
import bisect
import json
from typing import Any, Dict, List, Tuple

# 3rd party libraries
import requests

# Internal libraries
from onclusiveml.core.logging import get_default_logger

# Source
from src.settings import get_api_settings


settings = get_api_settings()
logger = get_default_logger(__name__)


class TranscriptSegmentationHandler:
    """Transcript Segmentation using prompt backend."""

    output_truncated: bool = False
    input_truncated: bool = False

    def find_last_occurrence(self, phrase: str, transcript: str) -> int:
        """Find index of the last mention of phrase.

        Args:
            phrase (str): Given phrase
            transcript (str): Stringified transcript

        Returns:
            int: Index of the last mentioned phrase
        """
        position = transcript.rfind(phrase)
        return position

    def remove_newlines(self, segmented_transcript: str) -> str:
        """Remove new lines from the string.

        Args:
            segmented_transcript (str): Stringified JSON from GPT

        Returns:
            str: Stringified JSON without new lines
        """
        segmented_transcript = segmented_transcript.replace("\n    ", "")
        segmented_transcript = segmented_transcript.replace("\n", "")
        return segmented_transcript

    def related_segment(self, json_segmented_transcript: Dict[str, Any]) -> Any:
        """Find the related segment key in the dictionary holding timestamps and content.

        Args:
            json_segmented_transcript (Dict[str, Any]): JSON from GPT

        Returns:
            Dict[str, Any]: Dictionary of timestamp and content
        """
        if "Related segment" in json_segmented_transcript:
            return json_segmented_transcript["Related segment"]

    def insert_sorted(
        self,
        lst: List[Dict[str, Any]],
        item: Dict[str, Any],
    ) -> List[Dict[str, Any]]:
        """Insert content into the right position in the list based on timestamp.

        Args:
            lst (List[Dict[str, Any]]): List of timestamps and content
            item (Dict[str, Any]): A singular timestamp and content as a dictionary

        Returns:
            List[Dict[str, Any]]: List of timestamps and content with correctly inserted item
        """
        # Finds location to place item in list and maintain start_time order
        start_time_values = [i["start_time"] for i in lst]
        bisect.insort(start_time_values, item["start_time"])
        index = start_time_values.index(item["start_time"])
        lst.insert(index, item)
        return lst

    def content_search(
        self,
        json_segmented_transcript: List[Dict[str, Any]],
        keyword: str,
        truncated_sentence_transcript: List[Dict[str, Any]],
    ) -> List[Dict[str, Any]]:
        """Find content from the input transcript using string match and merge with GPT output.

        Args:
            json_segmented_transcript (List[Dict[str, Any]]): Transcript from GPT output
            keyword (str): Keyword
            truncated_sentence_transcript (List[Dict[str, Any]]): truncated sentence transcript

        Returns:
            List[Dict[str, Any]]: Transcript merged from both string search and GPT output
        """
        for i in truncated_sentence_transcript:
            if keyword in i["content"] or keyword.lower() in i["content"]:
                # If item from transcript from string match doesn't exist, add to final output
                if i not in json_segmented_transcript:
                    json_segmented_transcript = self.insert_sorted(
                        json_segmented_transcript, i
                    )
        return json_segmented_transcript

    def postprocess(
        self,
        segmented_transcript: str,
        keyword: str,
        truncated_sentence_transcript: List[Dict[str, Any]],
    ) -> List[Dict[str, Any]]:
        """Post-process GPT output by removing new lines and adding content found by string match.

        Args:
            segmented_transcript (str): Transcript generated by GPT
            keyword (str): Keyword used to query the transcript
            truncated_sentence_transcript (List[Dict[str, Any]]): sentence-based transcript

        Returns:
            List[Dict[str, Any]]: Transcript merged from both string search and GPT output
        """
        str_segmented_transcript = self.remove_newlines(segmented_transcript)
        self.output_truncated = False

        # if list of json objects is incomplete, trim it and then complete object
        try:
            json_segmented_transcript = eval(str_segmented_transcript)
        except SyntaxError:
            # Find last complete json object and close the list
            position = self.find_last_occurrence(
                """,{  "start_time":""", str_segmented_transcript
            )
            str_segmented_transcript = str_segmented_transcript[:position] + "]}"
            self.output_truncated = True
            json_segmented_transcript = eval(str_segmented_transcript)

        json_segmented_transcript = self.related_segment(json_segmented_transcript)

        # Use string search to find any parts of transcript that gpt may have missed
        result_segmented_transcript = self.content_search(
            json_segmented_transcript, keyword, truncated_sentence_transcript
        )
        return result_segmented_transcript

    def truncate_transcript(
        self,
        preprocessed_sentence_transcript: List[Dict[str, Any]],
        threshold: int = 300000,
    ) -> List[Dict[str, Any]]:
        """Truncate transcript to fit into the model.

        Args:
            transcript (List[Dict[str, Any]]): Sentence-based transcript
            threshold (int): Max character length of transcript

        Returns:
            List[Dict[str, Any]]: Truncated transcript
        """
        str_sentence_transcript = str(preprocessed_sentence_transcript)
        self.input_truncated = False
        if len(str_sentence_transcript) > threshold:
            # Find last complete json object from the truncated transcript and close the list
            str_sentence_transcript = str_sentence_transcript[:threshold]
            position = self.find_last_occurrence(
                """, {\'start_time\':""", str_sentence_transcript
            )
            str_sentence_transcript = str_sentence_transcript[:position] + "]"
            self.input_truncated = True
        truncated_sentence_transcript = eval(str_sentence_transcript)
        return truncated_sentence_transcript

    def preprocess_transcript(
        self, word_transcript: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Convert word-based transcript into sentence-based.

        Args:
            word_transcript (List[Dict[str, Any]): Word-based transcript

        Returns:
            List[Dict[str, Any]: Transcript converted into sentences
        """
        transcript_preprocessed = []
        transcript_dict: Dict[str, Any] = {}

        # Iterate over each word from word-based transcript and merge into sentences
        for i in word_transcript:
            if i["w"] is not None:
                if not transcript_dict:
                    transcript_dict["start_time"] = i["ts"]

                if "content" not in transcript_dict:
                    transcript_dict["content"] = str(i["w"])  # Convert to string
                else:
                    transcript_dict["content"] += " " + str(i["w"])  # Convert to string
                if len(transcript_dict["content"]) > 0:
                    # If contain certain punctuation, complete the sentence and start new sentence
                    if transcript_dict["content"][-1] in [".", "!", "?"]:
                        transcript_preprocessed.append(transcript_dict)
                        transcript_dict = {}

        if transcript_dict:
            if len(transcript_dict["content"]) > 0:
                if transcript_dict["content"][-1] in [".", "!", "?"]:
                    transcript_preprocessed.append(transcript_dict)
                    transcript_dict = {}
        return transcript_preprocessed

    def __call__(
        self,
        word_transcript: List[Dict[str, Any]],
        keyword: str,
    ) -> Tuple[List[Dict[str, Any]], bool, bool]:
        """Prediction method for transcript segmentation.

        Args:
            transcript (List[Dict[str, Any]]): Inputted word-based transcript
            keyword (str): Keyword to query the transcript

        Returns:
            Tuple[List[Dict[str, Any]], bool, bool]: Segmented transcript based on a keyword
        """
        # preprocess
        preprocessed_sentence_transcript = self.preprocess_transcript(word_transcript)
        # truncate
        truncated_sentence_transcript = self.truncate_transcript(
            preprocessed_sentence_transcript
        )

        headers = {"x-api-key": settings.internal_ml_endpoint_api_key}
        payload = {"transcript": truncated_sentence_transcript, "keyword": keyword}
        q = requests.post(
            "{}/api/v1/prompts/{}/generate".format(
                settings.prompt_api_url, settings.prompt_alias
            ),
            headers=headers,
            json=payload,
        )

        # post process
        post_process_transcript = self.postprocess(
            segmented_transcript=json.loads(q.content)["generated"],
            keyword=keyword,
            truncated_sentence_transcript=truncated_sentence_transcript,
        )

        return post_process_transcript, self.output_truncated, self.input_truncated
